open list
open nest

data mutable graph a =
  (g: Graph {
    roots: list (nested_node g a)
  })

and alias nested_node (g: value) a =
  (n: unknown | nests g (n @ node g a))

and mutable node (g: value) a =
  Node {
    seen: bool;
    contents: a;
    neighbors: list (nested_node g a)
  }

val g: graph int =
  let g = Graph {
    roots = nil
  } in
  let n = Node {
    seen = false;
    contents = 10;
    neighbors = nil;
  } in
  nest [g, (n @ node g int)] ();
  consult (fun (| n @ node g int): () =
    n.neighbors <- cons [nested_node g int] (n, nil);
  );
  g.roots <- cons (n, nil);
  g

val dfs [a] (g: graph a, f: a -> ()): () =
  let work_list = newref nil in
  let rec dfs (n: nested_node g a | g @ graph a * work_list @ ref (list (nested_node g a))): () =
    focus [g, (n @ node g a)] ();
    if not n.seen then begin
      f n.contents;
      work_list := append (n.neighbors, !work_list);
      n.seen <- true;
    end;
    defocus [g] ();
    match !work_list with
    | Cons { head; tail } ->
        work_list := tail;
        dfs head
    | Nil ->
        ()
    end
  in
  iter (g.roots, dfs)

val _ =
  dfs (g, print)
