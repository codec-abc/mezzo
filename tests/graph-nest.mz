open list
open nest

data mutable graph a =
  (g: Graph {
    roots: list (nested_node g a)
  })

and alias nested_node (g: value) a =
  (n: unknown | nests g (n @ node g a))

and mutable node (g: value) a =
  Node {
    seen: bool;
    contents: a;
    neighbors: list (nested_node g a)
  }

val g: graph int =
  let g = Graph {
    roots = nil
  } in
  let n = Node {
    seen = false;
    contents = 10;
    neighbors = nil;
  } in
  nest [g, (n @ node g int)] ();
  consult (fun (| n @ node g int): () =
    n.neighbors <- cons [nested_node g int] (n, nil);
  );
  g.roots <- cons (n, nil);
  g

val dfs [a] (g: graph a, f: a -> ()): () =
  let s = stack::new [nested_node g a] g.roots in
  stack::work (s, fun (n: nested_node g a | g @ graph a * s @ stack::stack (nested_node g a)): () =
    focus [g, (n @ node g a)] ();
    if not n.seen then begin
      f n.contents;
      stack::push (n.neighbors, s);
      n.seen <- true;
    end;
    defocus [g] ();
  )

val _ =
  dfs (g, print)
