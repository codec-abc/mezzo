diff --git a/GNUmakefile b/GNUmakefile
deleted file mode 100644
index ec5a34c..0000000
--- a/GNUmakefile
+++ /dev/null
@@ -1,208 +0,0 @@
-# -------------------------------------------------------------------------
-
-# This is the development Makefile. It is used for compiling
-# development versions and for creating the distributed package.
-# This Makefile is not distributed.
-
-SHELL := bash
-
-.PHONY: all test clean package check export godi
-
-# -------------------------------------------------------------------------
-
-# A dummy entry.
-
-all:
-	@echo Please go down into src/ if you wish to compile Menhir.
-
-# -------------------------------------------------------------------------
-
-# Testing.
-# Assumes that "make bootstrap" has been run in src/
-# or that MENHIR is properly set.
-
-test:
-	$(MAKE) -C bench
-
-# -------------------------------------------------------------------------
-
-# Cleaning up.
-
-clean:
-	@ for i in bench demos src ; do \
-	  $(MAKE) -C $$i $@ ; \
-	done
-	$(MAKE) -rs -C doc $@
-
-# -------------------------------------------------------------------------
-
-# Prevent the built-in bash cd from displaying information.
-
-export CDPATH=
-
-# Distribution.
-# The version number is automatically set to the current date.
-
-DATE     := $(shell /bin/date +%Y%m%d)
-PACKAGE  := menhir-$(DATE)
-CURRENT  := $(shell pwd)
-TARBALL  := $(CURRENT)/$(PACKAGE).tar.gz
-HEADACHE := headache
-SRCHEAD  := $(CURRENT)/header
-LIBHEAD  := $(CURRENT)/lgpl-header
-
-# GODI settings. We assume $(GODI_HOME) is defined and points
-# to the host machine's GODI installation.
-
-GODINAME := godi/godi-menhir
-GODIWORK := /home/fpottier/dev/godi-build
-GODISVN  := $(GODIWORK)/trunk/$(GODINAME)
-GODIH    := $(GODI_HOME)/build/$(GODINAME)
-GODIPACK := $(GODIWORK)/pack
-GODIMAP  := $(GODIPACK)/release.4.00.map
-GODIURL  := https://godirepo.camlcity.org/godi_admin
-GODIVA   := $(GODI_HOME)/bin/godiva
-
-# A list of files to copy without changes to the package.
-#
-# This does not include the src/ and doc/ directories, which require
-# special treatment.
-
-DISTRIBUTED_FILES := AUTHORS CHANGES INSTALLATION LICENSE Makefile demos
-
-# Some source files carry the "library" license, while others carry
-# the regular "source code" license.
-
-LIBFILES := \
-  src/standard.mly \
-  src/infiniteArray.{ml,mli} \
-  src/packedIntArray.{ml,mli} \
-  src/rowDisplacement.{ml,mli} \
-  src/engineTypes.ml \
-  src/engine.{ml,mli} \
-  src/tableFormat.ml \
-  src/tableInterpreter.{ml,mli} \
-  src/convert.{ml,mli}
-
-package: clean
-# Create a directory to store the distributed files temporarily.
-	@ rm -fr $(PACKAGE)
-	@ mkdir -p $(PACKAGE)/src
-	@ cp -fr $(DISTRIBUTED_FILES) $(PACKAGE)
-	@ cp -fr src/*.ml{,i,y,l,pack} src/Makefile src/_tags src/META $(PACKAGE)/src
-	@ $(MAKE) -C $(PACKAGE)/demos clean
-# Insert headers.
-	@ echo "-> Inserting headers."
-	@ cd $(PACKAGE) && find . -regex ".*\.ml\(i\|y\|l\)?" \
-	    -exec $(HEADACHE) -h $(SRCHEAD) "{}" ";"
-	@ cd $(PACKAGE) && for file in $(LIBFILES) ; do \
-	    $(HEADACHE) -h $(LIBHEAD) $$file ; \
-	  done
-# Set the version number into the files that mention it. These
-# include version.ml, version.tex, META.
-	@ echo "-> Setting version to $(DATE)."
-	@ echo let version = \"$(DATE)\" > $(PACKAGE)/src/version.ml
-	@ echo version = \"$(DATE)\" >> $(PACKAGE)/src/META
-# Copy and compile the documentation.
-	@ echo "-> Generating the documentation."
-	@ cp -r doc $(PACKAGE)
-	@ echo '\gdef\menhirversion{$(DATE)}' > $(PACKAGE)/doc/version.tex
-	@ make -C $(PACKAGE)/doc clean all
-	@ mv $(PACKAGE)/doc/main.pdf $(PACKAGE)/manual.pdf
-	@ mv $(PACKAGE)/doc/menhir.1 $(PACKAGE)/
-	@ rm -rf $(PACKAGE)/doc
-# Create the API documentation.
-	@ $(MAKE) -C src api
-# Create the tarball.
-	@ echo "-> Tarball creation."
-	tar --exclude=.svn -cvz -f $(TARBALL) $(PACKAGE)
-	@ echo "-> Package $(PACKAGE).tar.gz is ready."
-
-check:
-	@ echo "-> Checking the package ..."
-# Create a temporary directory; extract, build, and install the
-# package into it; run the test suite using the installed binary.
-	@ TEMPDIR=`mktemp -d /tmp/menhir-test.XXXXXX` && { \
-	echo "   * Extracting. " && \
-	(cd $$TEMPDIR && tar xfz $(TARBALL)) && \
-	echo "   * Compiling and installing." && \
-	mkdir $$TEMPDIR/install && \
-	(cd $(PACKAGE) \
-		&& make PREFIX=$$TEMPDIR/install USE_OCAMLFIND=false all install \
-	) > $$TEMPDIR/install.log 2>&1 \
-		|| (cat $$TEMPDIR/install.log; exit 1) && \
-	echo "   * Running the test suite." && \
-	$(MAKE) MENHIR=$$TEMPDIR/install/bin/menhir test > $$TEMPDIR/test.log 2>&1 \
-		|| (cat $$TEMPDIR/test.log; exit 1) && \
-	rm -fr $$TEMPDIR ; }
-	@ echo "-> Package $(PACKAGE) seems ready for distribution!"
-
-# -------------------------------------------------------------------------
-
-# Copying to my Web site.
-
-RSYNC   := scp -p -B -C
-TARGET  := yquem.inria.fr:public_html/menhir/
-PAGE    := /home/fpottier/dev/page
-
-export:
-# Copier l'archive et la doc vers yquem.
-	$(RSYNC) $(TARBALL) $(TARGET)
-	$(RSYNC) $(PACKAGE)/manual.pdf $(TARGET)
-	$(RSYNC) CHANGES $(TARGET)
-# Copier l'API vers la page Web.
-	cd src && $(RSYNC) convert.mli.html $(TARGET)
-# Mettre à jour la page Web de Menhir avec le nouveau numéro de version.
-	cd $(PAGE) && \
-	  sed --in-place=.bak "s/menhir-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]/$(PACKAGE)/" menhir.xml && \
-	  $(MAKE) export && \
-	  cvs commit -m "Updated Menhir's version number."
-
-# -------------------------------------------------------------------------
-
-# Creating a GODI package.
-
-# This entry assumes that "make package" and "make export" have been
-# run on the same day. It must have sufficient rights to write into
-# the local GODI hierarchy.
-
-godi:
-	@ if [ `whoami` != "root" ] ; then \
-	  echo "make godi must be run with root privileges. Try running ./godi" ; \
-	  exit 1 ; \
-	fi
-	@ sed -e s/VERSION/$(DATE)/ < spec.godiva > $(GODISVN)/spec.godiva
-	@ cd $(GODIWORK) && svn up
-	@ cd $(GODISVN) && \
-          $(GODIVA) -refetch -localbase $(GODI_HOME) spec.godiva && \
-	  rsync -v -r $(GODIH)/ $(GODISVN) && \
-	  chown -R fpottier $(GODISVN)
-	@ echo "Do you wish to proceed and commit changes to GODI (yes or no)?"
-	@ read answer && if [ "$$answer" != "yes" ] ; then \
-	  echo Aborting. ; \
-	  exit 1 ; \
-	fi
-	@ cd $(GODISVN) && \
-	  svn commit -m "Changes to Menhir package." && \
-	  export revision=`svn info Makefile | sed -n 's/^R.vision \?: \([0-9]\+\)$$/\1/p'` && \
-	  echo Revision is now $$revision. && \
-	  for map in $(GODIMAP) ; do \
-	    sed --in-place=.bak "s/^\(.*menhir[^0-9]*\)[0-9]\+$$/\1$$revision/" $$map ; \
-	  done
-	@ echo Here are my changes to the release maps:
-	@ cd $(GODIPACK) && svn diff --diff-cmd diff -x "-C0"
-	@ echo "Do you wish to proceed and commit changes to GODI (yes or no)?"
-	@ read answer && if [ "$$answer" != "yes" ] ; then \
-	  echo Aborting. ; \
-	  exit 1 ; \
-	fi
-	@ cd $(GODIPACK) && svn commit -m "Updated release map for Menhir."
-	@ echo "You may now open GODI's release tool at"
-	@ echo "        $(GODIURL)"
-	@ echo "and proceed as directed. I will try to open this URL for you."
-	@ case $$OSTYPE in \
-	(linux*) \
-	  su fpottier -c "firefox $(GODIURL)" ;; \
-	(*) \
-	  open $(GODIURL) ;; \
-	esac
diff --git a/src/_tags b/src/_tags
index 6cb48a2..a1b46d6 100644
--- a/src/_tags
+++ b/src/_tags
@@ -25,3 +25,5 @@
 <tableFormat.cmx>: for-pack(MenhirLib)
 <tableInterpreter.cmx>: for-pack(MenhirLib)
 <convert.cmx>: for-pack(MenhirLib)
+
+true: annot
diff --git a/src/engine.ml b/src/engine.ml
index 367008c..b3fcc44 100644
--- a/src/engine.ml
+++ b/src/engine.ml
@@ -65,10 +65,38 @@ module Make (T : TABLE) = struct
      Here, the code is structured in a slightly different way. It is up to
      the caller of [run] to indicate whether to discard a token. *)
 
-  let rec run env please_discard : void =
+  type env = (state, semantic_value, T.token) EngineTypes.env
+  type what =
+    | WRun of env * bool
+    | WContinue of env
+    | WAction of env
+    | WShift of env * bool * terminal * semantic_value * state
+    | WReduce of env * production
+    | WInitiate of env
+    | WErrorBookkeeping of env
+    | WError of env
+    | WErrorShift of env * bool * terminal * semantic_value * state
+    | WErrorReduce of env * production
+    | WErrorFail of env
+
+  let stack = ref []
+
+  let loop action =
+    stack := action :: !stack
+
+  let pop (): unit =
+
+    match !stack with
+    | [] -> ()
+    | hd :: tl ->
+    stack := tl;
+
+    match hd with
+
+    | WRun (env, please_discard) ->
 
     (* Log the fact that we just entered this state. *)
-    
+
     let s = env.current in
     Log.state s;
 
@@ -86,11 +114,11 @@ module Make (T : TABLE) = struct
 
     T.default_reduction
       s
-      reduce   (* there is a default reduction; perform it *)
-      continue (* there is none; continue below *)
+      (fun env prod -> loop (WReduce (env, prod)))   (* there is a default reduction; perform it *)
+      (fun env -> loop (WContinue env)) (* there is none; continue below *)
       env
 
-  and continue env : void =
+    | WContinue env ->
 
     (* There is no default reduction. Consult the current lookahead token
        so as to determine which action should be taken. *)
@@ -105,10 +133,10 @@ module Make (T : TABLE) = struct
 
     if env.shifted = (-1) then begin
       Log.resuming_error_handling();
-      error env
+      loop (WError env)
     end
     else
-      action env
+      loop (WAction env)
 
   (* --------------------------------------------------------------------------- *)
 
@@ -116,7 +144,7 @@ module Make (T : TABLE) = struct
      a default reduction. We also know that the current lookahead token is
      not [error]: it is a real token, stored in [env.token]. *)
 
-  and action env : void =
+    | WAction env ->
 
     (* We consult the two-dimensional action table, indexed by the
        current state and the current lookahead token, in order to
@@ -127,9 +155,9 @@ module Make (T : TABLE) = struct
       env.current                    (* determines a row *)
       (T.token2terminal token)       (* determines a column *)
       (T.token2value token)
-      shift                          (* shift continuation *)
-      reduce                         (* reduce continuation *)
-      initiate                       (* failure continuation *)
+      (fun a b c d e -> loop (WShift (a, b, c, d, e)))                          (* shift continuation *)
+      (fun a b -> loop (WReduce (a, b)))                         (* reduce continuation *)
+      (fun a -> loop (WInitiate a))                       (* failure continuation *)
       env
 
   (* --------------------------------------------------------------------------- *)
@@ -138,12 +166,7 @@ module Make (T : TABLE) = struct
      (Goto transitions are taken care of within [reduce] below.) The symbol
      can be either an actual token or the [error] pseudo-token. *)
 
-  and shift env
-      (please_discard : bool)
-      (terminal : terminal)
-      (value : semantic_value)
-      (s' : state)
-      : void =
+    | WShift (env, please_discard, terminal, value, s') ->
 
     (* Log the transition. *)
 
@@ -164,13 +187,13 @@ module Make (T : TABLE) = struct
     (* Switch to state [s']. *)
 
     env.current <- s';
-    run env please_discard
+    loop (WRun (env, please_discard))
 
   (* --------------------------------------------------------------------------- *)
 
   (* This function takes care of reductions. *)
 
-  and reduce env (prod : production) : void =
+    | WReduce (env, prod) ->
 
     (* Log a reduction event. *)
 
@@ -204,11 +227,11 @@ module Make (T : TABLE) = struct
 	 production [prod]. *)
 
       env.current <- T.goto env.stack.state prod;
-      run env false
+      loop (WRun (env, false))
 
     end
     else
-      errorbookkeeping env
+      loop (WErrorBookkeeping env)
 
 
   (* --------------------------------------------------------------------------- *)
@@ -218,26 +241,28 @@ module Make (T : TABLE) = struct
   (* [initiate] and [errorbookkeeping] initiate error handling. See the functions
      by the same names in [CodeBackend]. *)
 
-  and initiate env : void =
+    | WInitiate env ->
+
     assert (env.shifted >= 0);
     if T.recovery && env.shifted = 0 then begin
       Log.discarding_last_token (T.token2terminal env.token);
       discard env;
       env.shifted <- 0;
-      action env
+      loop (WAction env)
     end
     else
-      errorbookkeeping env
+      loop (WErrorBookkeeping env)
+
+    | WErrorBookkeeping env ->
 
-  and errorbookkeeping env =
     Log.initiating_error_handling();
     env.previouserror <- env.shifted;
     env.shifted <- (-1);
-    error env
+    loop (WError env)
 
   (* [error] handles errors. *)
 
-  and error env : void =
+    | WError env ->
 
     (* Consult the column associated with the [error] pseudo-token in the
        action table. *)
@@ -246,12 +271,12 @@ module Make (T : TABLE) = struct
       env.current                    (* determines a row *)
       T.error_terminal               (* determines a column *)
       T.error_value
-      error_shift                    (* shift continuation *)
-      error_reduce                   (* reduce continuation *)
-      error_fail                     (* failure continuation *)
+      (fun a b c d e -> loop (WErrorShift (a, b, c, d, e)))                    (* shift continuation *)
+      (fun a b -> loop (WErrorReduce (a, b)))                   (* reduce continuation *)
+      (fun a -> loop (WErrorFail a))                     (* failure continuation *)
       env
 
-  and error_shift env please_discard terminal value s' =
+    | WErrorShift (env, please_discard, terminal, value, s') ->
 
     (* Here, [terminal] is [T.error_terminal], and [value] is [T.error_value]. *)
 
@@ -260,16 +285,16 @@ module Make (T : TABLE) = struct
     (* This state is capable of shifting the [error] token. *)
 
     Log.handling_error env.current;
-    shift env please_discard terminal value s'
+    loop (WShift (env, please_discard, terminal, value, s'))
 
-  and error_reduce env prod =
+    | WErrorReduce (env, prod) ->
 
     (* This state is capable of performing a reduction on [error]. *)
 
     Log.handling_error env.current;
-    reduce env prod
+    loop (WReduce (env, prod))
 
-  and error_fail env =
+    | WErrorFail env ->
 
     (* This state is unable to handle errors. Attempt to pop a stack
        cell. *)
@@ -289,7 +314,7 @@ module Make (T : TABLE) = struct
 
       env.stack <- next;
       env.current <- cell.state;
-      error env
+      loop (WError env)
 
     end
 
@@ -342,8 +367,11 @@ module Make (T : TABLE) = struct
       (* If ocaml offered a [match/with] construct with zero branches, this is
 	 what we would use here, since the type [void] has zero cases. *)
 
-      let (_ : void) = run env false in
-      assert false (* cannot fail *)
+      loop (WRun (env, false));
+      while !stack <> [] do
+        pop ()
+      done;
+      assert false
 
     with
     | Accept v ->
